import { basename } from 'path';

export interface BootstrapInputs {
  projectName: string;
  testCommand: string;
  buildCommand: string;
  requiredChecks: string[];
}

interface MinimalRuntimeConfig {
  commands?: {
    test?: string;
    build?: string;
  };
}

interface MinimalPolicy {
  checks?: {
    required?: string[];
  };
}

interface MinimalPackageJson {
  name?: string;
  scripts?: Record<string, string>;
}

export async function detectBootstrapInputs(
  repoRoot: string,
  readFile: (path: string, encoding: 'utf-8') => Promise<string>,
): Promise<BootstrapInputs> {
  const packageJsonPath = `${repoRoot}/package.json`;
  const configPath = `${repoRoot}/ralph.config.json`;
  const policyPath = `${repoRoot}/ralph.policy.json`;

  const pkg = await readJson<MinimalPackageJson>(packageJsonPath, readFile);
  const config = await readJson<MinimalRuntimeConfig>(configPath, readFile);
  const policy = await readJson<MinimalPolicy>(policyPath, readFile);

  const projectName = pkg?.name?.trim() || basename(repoRoot);
  const testCommand = config?.commands?.test || pkg?.scripts?.test || 'npm test';
  const buildCommand = config?.commands?.build || pkg?.scripts?.build || 'npm run build';
  const requiredChecks = (policy?.checks?.required || ['test', 'build']).filter(Boolean);

  return {
    projectName,
    testCommand,
    buildCommand,
    requiredChecks,
  };
}

async function readJson<T>(
  path: string,
  readFile: (path: string, encoding: 'utf-8') => Promise<string>,
): Promise<T | null> {
  try {
    const raw = await readFile(path, 'utf-8');
    return JSON.parse(raw) as T;
  } catch {
    return null;
  }
}

export function buildBootstrapArtifacts(
  input: BootstrapInputs,
  now: Date = new Date(),
): Record<string, string> {
  const generatedAt = now.toISOString();

  return {
    'specs/system-context.md': buildSystemContextSpec(input, generatedAt),
    'specs/architecture.md': buildArchitectureSpec(input, generatedAt),
    'specs/delivery-workflow.md': buildDeliveryWorkflowSpec(input, generatedAt),
    'specs/quality-gates.md': buildQualityGatesSpec(input, generatedAt),
    'implementation-plan.md': buildImplementationPlan(input, generatedAt),
  };
}

export function buildSystemContextSpec(input: BootstrapInputs, generatedAt: string): string {
  return `# System Context

> Baseline context generated by Ralph bootstrap.

## Project

- Name: \`${input.projectName}\`
- Generated at: \`${generatedAt}\`

## Goal

Deliver scoped features safely with human-on-the-loop governance.

## Constraints

- Markdown is the source of truth for plans and specs.
- One task is executed at a time.
- Policy checks gate commits and promotions.

## Stakeholders

- Product owner / project maintainer
- Delivery engineer(s)
- Human reviewer for gated actions
`;
}

export function buildArchitectureSpec(input: BootstrapInputs, generatedAt: string): string {
  return `# Architecture

> Baseline architecture note generated by Ralph bootstrap.

## Project

- Name: \`${input.projectName}\`
- Generated at: \`${generatedAt}\`

## Current Shape

Document the current runtime stack, boundaries, and key modules in this file before high-autonomy execution.

## Required Sections

- System boundaries and external dependencies
- Data/storage boundaries
- Build and deployment surfaces
- Risk hotspots
`;
}

export function buildDeliveryWorkflowSpec(input: BootstrapInputs, generatedAt: string): string {
  return `# Delivery Workflow

> Baseline workflow generated by Ralph bootstrap.

## Project

- Name: \`${input.projectName}\`
- Generated at: \`${generatedAt}\`

## Lifecycle

\`draft -> pending_review -> approved | rejected -> applied\`

## Task Patterns

- Bugfix
- Feature
- Migration
- Test hardening

## Execution Rules

- Execute one task at a time in sandbox.
- Run required checks after implementation.
- Rollback on failure.
- Keep human approval for destructive, dependency, and production-impacting changes.
`;
}

export function buildQualityGatesSpec(input: BootstrapInputs, generatedAt: string): string {
  const checks = input.requiredChecks.length > 0 ? input.requiredChecks.join(', ') : 'test, build';
  return `# Quality Gates

> Baseline quality gates generated by Ralph bootstrap.

## Project

- Name: \`${input.projectName}\`
- Generated at: \`${generatedAt}\`

## Commands

- Test: \`${input.testCommand}\`
- Build: \`${input.buildCommand}\`

## Required Checks

- \`${checks}\`

## Gate Policy

- All required checks must pass before commit.
- Failing checks trigger rollback when policy sets \`rollbackOnFail: true\`.
- Human approval is required for gated approval classes.
`;
}

export function buildImplementationPlan(input: BootstrapInputs, generatedAt: string): string {
  return `# Implementation Plan â€” ${input.projectName}

> Baseline delivery plan generated by Ralph bootstrap on ${generatedAt}.

## Goal

Deliver scoped features safely for this repository with policy-gated autonomy.

## Phase 0: Onboarding

- [ ] Validate required files and wiring: \`AGENTS.md\`, \`implementation-plan.md\`, \`ralph.config.json\`, \`ralph.policy.json\`
- [ ] Validate test/build commands from [specs/quality-gates.md](./specs/quality-gates.md)
- [ ] Validate policy gates and approval classes from [specs/delivery-workflow.md](./specs/delivery-workflow.md)

## Phase 1: Baseline Specs

- [ ] Confirm project context in [specs/system-context.md](./specs/system-context.md)
- [ ] Confirm architecture boundaries in [specs/architecture.md](./specs/architecture.md)
- [ ] Confirm lifecycle and approvals in [specs/delivery-workflow.md](./specs/delivery-workflow.md)
- [ ] Confirm command and gate setup in [specs/quality-gates.md](./specs/quality-gates.md)

## Phase 2: Initial Task Graph

- [ ] Extract tasks from [specs/system-context.md](./specs/system-context.md) and [specs/architecture.md](./specs/architecture.md)
- [ ] Extract tasks from [specs/delivery-workflow.md](./specs/delivery-workflow.md) and [specs/quality-gates.md](./specs/quality-gates.md)
- [ ] Prioritize the first delivery slice with explicit acceptance criteria

## Phase 3: Controlled Execution

- [ ] Execute one task at a time under policy checks
- [ ] Run \`${input.testCommand}\` and \`${input.buildCommand}\` for each completed slice
- [ ] Record outcomes in \`state/progress.jsonl\` and \`state/learning.jsonl\`
`;
}
